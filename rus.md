#Организация кода CSS препроцессоров

CSS препроцессоры, возможно, один из самых полезных инструментов во фронтенде.
Неважно выбрали ли вы Sass, LESS, или какой-то другой препроцессор, все они 
добавляют множество новых возможностей в CSS. Однако, я не пытаюсь убедить вас 
использовать препроцессоры, я полагаю, если вы читаете эту статью, то вы уже 
их используете.

Дальше мы с вами исследуем несколько различных вариантов архитектур, которые
вы можете использовать с выбранным препроцессором, чтобы найди подходящую 
именно вам. Во всех архитектурах используются Sass файлы (т.е. .scss), и, 
несмотря на это, они легко адаптируются под любой препроцессор.

##Архитектуры?

Одна из самых привлекательных возможностей CSS препроцессоров - подключение 
файлов. Это позволяет нам распределять код на несколько файлов, которые 
впоследствии будут объединены препроцессором. Таким образом, мы можем работать 
с отдельными файлами и не беспокоиться о длинном списке HTTP запросов.

Сперва вы будете сомневаться в полезности данной возможности. Но лишь 
до тех пор, пока не начнете работать с большим проектом. Именно тогда ваш 
стройный файл со стилями превратится в неаппетитное месиво. В моем случае 
произошло именно так, и я остро нуждался в структуризации кода.

Итак, что же мы имеем? CSS не поддается программированию, так что мы не имеем 
возможности попросту нагло скопировать одну из архитектур программирования. 
Как же нам тогда организовать различные части наших стилей? Пакуйте чемоданы, 
впрыгивайте в ботинки и добро пожаловать в чудный новый мир, который я для вас 
открою (в смысле - просто расслабьтесь и позвольте мне сделать всю тяжелую 
исследовательскую работу за вас).

> Все архитектуры начинаются с папки base. В ней лежат файлы, которые не
> следует трогать(например файл reset или стили для подключаемых библиотек).


###Функциональное распределение

Это структура, которая рано или поздно приходит в голову, если вы новичок в
препроцессорах. Распределить функциональность на отдельные файлы и вправду
кажется очень логичным. Один файл для всех переменных, один для примесей и т.д.
и, наконец, один для текущих стилей. Давайте добавим еще `normalize.scss` ради
реализма .

*   /base 
*   _mixins.scss
*   _variables.scss
*   screen.scss

####Достоинства

* Красивый список примесей и переменных

####Недостатки

* Все стили в одном файле

####Вывод

Итак все не так уж и замечательно. В итоге мы просто получили огромный скрипт. 
С тем же успехом мы могли вообще не использовать препроцессор. Хотя, результат
успешно сочетается с другими архитектурами. По факту, именно в этом мы и
нуждаемся. Но разве только в этом? Не самая лучшая идея.

###Распределение "Катана"

Ну, а если, скажем, разделить страницы на части и обозначить стили для каждой
части индивидуально?

*   /base 
*   /sections 
    *   _header.scss
    *   _content.scss
    *   _footer.scss
    *   _sidebar.scss
    *   _modals.scss
*   _mixins.scss
*   _variables.scss
*   screen.scss

####Достоинства

* Имеет смысл
* Вряд ли есть двойные селекторы

####Недостатки

* Можно запутаться, особенно если у вас много различных украшений
* Скрипты могут быть довольно объемными, в частности `content.css`

####Вывод

К сожалению, с помощью подобной структуры, вы мотивируете себя использовать 
стили исключительно в определенных областях страниц, и в результате получаете 
статичный CSS и множество двойных свойств (например. `border-radius`). Вы 
можете частично компенсировать этот недостаток используя примеси и переменные. 
Тем не менее, данный подход может пригодиться для для малых и средних проектов.

###Шаблонное или страничное распределение

Если описывать отдельные файлы стилей для каждого шаблона или страницы, то
легко найти какой-либо объект, особенно если он носит похожее название.

*   /base 
*   /templates 
    *   _category.scss
    *   _footer.scss
    *   _header.scss
    *   _index.scss
    *   _page.scss
    *   _single.scss
*   /pages 
*   _mixins.scss
*   _variables.scss
*   screen.scss

Вы можете заметить, что имена шаблонов выглядят очень похожими на имена 
шаблонов WordPress. Это сделано специально.

####Достоинства

* Хорошее распределение
* Легкий поиск
* Кастомизация каждого шаблона

####Недостатки

* Мы опять слишком сильно ушли в детализацию

####Вывод

Это еще одно возможное решение для отдельных проектов. На самом деле, данная и
предыдущая архитектуры образуют прекрасную пару, которая может 
неплохо работать. Этот вариант подходит для многих средних и крупных
проектов.

###В терминах веб-дизайна

Я слышал, как Крис Койер описывал эту архитектуру в ролике "[Рабочий 
процесс современного веб-дизайнера] [2]. Как и предполагает название данной
архитектуры, она предназначена для веб-дизайнеров. То есть комфортно ей 
воспользоваться смогут только люди знакомые как с дизайном, так и с 
профессиональным жаргоном.
Чего Крис не делал, так это не использовал папки, но они все же могут 
понадобиться.

*   _normalize.scss
*   _buttons.scss
*   _footer.scss
*   _grid.scss
*   _header.scss
*   _icons.scss
*   _navigation.scss
*   _typography.scss
*   screen.scss


####Достоинства

* Имеет смысл (для дизайнеров)

####Недостатки

* Пугает не-дизайнеров
* Довольно неряшлива
* Можно получить дубликаты селекторов

####Вывод

Я должен упомянуть, что тот список файлов, который показал Крис, был в три раза
больше приведенного  выше. Однако данная архитектура вполне работоспособна. На
самом деле, я нередко ею пользуюсь.

###Коктейль "Хьюго"

Чуть ранее в этом году Хьюго описал свою Sass архитектуру. Оказалось, это смесь
всего того, что мы обсуждали ранее.

*   /base 
    *   _normalize.scss
    *   _typography.scss
*   /components 
    *   _buttons.scss
    *   _navigation.scss
*   /helpers 
    *   _mixins.scss
    *   _variables.scss
*   /layout 
    *   _grid.scss
    *   _header.scss
    *   _footer.scss
*   /pages 
*   /themes 
*   /vendors 
    *   _bootstrap.scss
    *   _jquery-ui.scss
*   main.scss

####Достоинства

*   Маленькие файлы
*   Выглядит организовано

####Недостатки

*   Слишком много файлов и папок

####Вывод

Данная архитектура хорошо работает на больших проектах. Как я уже заметил 
ранее, это смесь всего, что мы обсуждали выше. Иногда мне кажется, что данная 
архитектура несколько перегруженна. Но с другой стороны я не работал над 
большим количеством масштабируемых проектов.

##Резюмируя

Все это - не более чем примеры различных архитектур. Я все еще нахожусь в 
поиске "той самой идеальной" архитектуры, если, конечно, она существует. Но,
даже если я ее и найду, это в любом случае будет моим субъективным мнением.

Тем не менее, это достаточно важный вопрос, и его стоит тщательно обдумать. 
Если у вас есть возможность избежать беспорядка, особенно в интерфейсах, когда 
вы начинаете новый проект, вы просто обязаны это сделать.

 [1]: http://flippinawesome.org/authors/tim-severien
 [2]: http://css-tricks.com/video-screencasts/124-a-modern-web-designers-workflow/
 [3]: http://www.sitepoint.com/architecture-sass-project/
