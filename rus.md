#Организация кода CSS препроцессоров

CSS препроцессоры возможно один из самых полезных инструментов во фронтенде.
Неважно выбрали ли вы Sass, LESS или какой-то другой препроцессор, все они 
добавляют очень много возможностей в CSS. Однако я не пытаюсь убедить вас 
использовать препроцессоры, я полагаю вы уже их используете.

Мы исследуем несколько различных архитектур, которые вы можете использовать с 
выбранным препроцессором, чтобы найди подходящую именно вам. Во всех 
архитектурах используются Sass файлы (т.е. .scss), и несмотря на это, они 
легко адаптируются под любой препроцессор.

##Архитектуры?

Одна из самых лучших возможностей CSS препроцессоров - подключение файлов, это
позволяет нам распределять код на несколько файлов. Эти файлы впоследствии
будут объединены препроцессором. Таким образом мы можем работать с отдельными 
файлами и не беспокоиться о длинном списке HTTP запросов.

Сперва вы будете сомневаться в полезности данной возможности. Однако только 
до тех пор, пока не начнете работать с большим проектом. Именно тогда ваш
файл со стилями превратится в полное месиво. В моем случае так и произошло, и я
остро нуждался в структуризации кода.

Итак, что же мы имеем? CSS не поддается программированию, так что мы не можем
просто нагло скопировать одну из архитектур программирования. Как же нам тогда
организовать различные части наших стилей? Пакуйте чемоданы, впрыгивайте в 
ботинки и добро пожаловать в чудный новый мир, который я для вас открою (в 
смысле - просто расслабьтесь и позвольте мне сделать всю тяжелую 
исследовательскую работу за вас).

> Все архитектуры начинаются с папки base. В ней лежат файлы, которые не
> следует трогать(например файл reset или стили для подключаемых библиотек).


###Функциональное распределение

Это структура, которая приходит в голову в конечном итоге, если вы новичок в
препроцессорах. Распределить функциональность на отдельные файлы действительно
кажется очень логичным. Один для всех переменных, один для примесей и т.д. и,
наконец, один для текущих стилей. Давайте добавим еще `normalize.scss` ради
реализма .

*   /base 
*   _mixins.scss
*   _variables.scss
*   screen.scss

####Достоинства

* Красивый список примесей и переменных

####Недостатки

* Все стили в одном файле

####Вывод

Итак все это не так уж и хорошо. Мы в итоге просто получили огромный скрипт. С
таким же успехом мы могли вообще не использовать препроцессор. Хотя результат
успешно сочетается с другими архитектурами. По факту мы в этом и нуждаемся. Но
разве только в этом? Не очень хорошая идея.

###Распределение "Катана"

Ну а если скажем разделить страницы на части и обозначить стили для каждой части индивидуально?

*   /base 
*   /sections 
    *   _header.scss
    *   _content.scss
    *   _footer.scss
    *   _sidebar.scss
    *   _modals.scss
*   _mixins.scss
*   _variables.scss
*   screen.scss

####Достоинства

* Имеет смысл
* Вряд ли есть двойные селекторы

####Недостатки

* Можно запутаться, особенно если у вас есть много различных украшений
* Скрипты могут быть довольно большими, в частности `content.css`

####Вывод

К сожалению, с помощью подобной структуры, вы мотивируете себя использовать 
стили исключительно в определенных областях страниц, в результате получаете 
статичный CSS и много двойных свойств (например. `border-radius`). Вы можете 
немного компенсировать этот недостаток используя примеси и переменные. Тем не 
менее, данный подход может пригодиться для для малых и средних проектов.

###Шаблонное или страничное распределение

Если описывать отдельные файлы стилей для каждого шаблона или страницы, легко 
найти какой-либо объект, особенно если он носит похожее наименование.

*   /base 
*   /templates 
    *   _category.scss
    *   _footer.scss
    *   _header.scss
    *   _index.scss
    *   _page.scss
    *   _single.scss
*   /pages 
*   _mixins.scss
*   _variables.scss
*   screen.scss

Вы можете заметить что имена шаблонов выглядят очень похоже на шаблоны 
WordPress. Я сделал это специально.

####Достоинства

* Хорошее распределение
* Легкий поиск
* Кастомизация каждого шаблона

####Недостатки

* Мы опять слишком ушли в детализацию

####Вывод

Это еще одно возможное решение для отдельных проектов. На самом деле 
предыдущая архитектура и эта образуют прекрасную пару, которая может 
достаточно хорошо работать. Этот вариант подходит для многих средних и крупных
проектов.

###В терминах веб-дизайна

Я слышал как Крис Койер описывал эту архитектуру в ролике "[Рабочий 
процесс современного веб-дизайнера] [2]. Как и предполагает название данной
архитектуры, она предназначена для веб-дизайнеров, то есть использовать ее с
комфортом смогут люди знакомые как с дизайном так и с профессиональным жаргоном
.
Чего Крис не делал, так это не использовал папки, но они могут быть необходимы.

*   _normalize.scss
*   _buttons.scss
*   _footer.scss
*   _grid.scss
*   _header.scss
*   _icons.scss
*   _navigation.scss
*   _typography.scss
*   screen.scss


####Достоинства

* Имеет смысл (для дизайнеров)

####Недостатки

* Пугает не-дизайнеров
* Довольно неряшлива
* Можно получить дубликаты селекторов

####Вывод

Я должен упомянуть что тот список файлов, который показал Крис, был в три раза
больше приведенного  выше. Однако данная архитектура вполне работоспособна. На
самом деле, я использую ее довольно часто.

###Коктейль "Хьюго"

Чуть ранее в этом году Хьюго описал свою Sass архитектуру. Оказалось это смесь
всего что мы обсуждали ранее.

*   /base 
    *   _normalize.scss
    *   _typography.scss
*   /components 
    *   _buttons.scss
    *   _navigation.scss
*   /helpers 
    *   _mixins.scss
    *   _variables.scss
*   /layout 
    *   _grid.scss
    *   _header.scss
    *   _footer.scss
*   /pages 
*   /themes 
*   /vendors 
    *   _bootstrap.scss
    *   _jquery-ui.scss
*   main.scss

####Достоинства

*   Маленькие файлы
*   Выглядит организовано

####Недостатки

*   Слишком много файлов и папок

####Вывод

Данная архитектура хорошо работает на больших проектах. Как я уже заметил 
ранее, это смесь всего, что мы обсуждали выше. Иногда я нахожду данную 
архитектуру слегка перегруженной. С другой стороны я не работал над большим
количеством масштабируемых проектов.

##Последнее слово

Все это не более чем примеры различных архитектур. Я все еще нахожусь в поиске 
"той самой идеальной" архитектуры, если, конечно, она существует. Но даже если
я ее и найду, это в любом случае будет моим субъективным мнением.

Тем не менее это достаточно важный вопрос чтобы тщательно его обдумать. Если
вы можете избежать беспорядка, особенно в интерфейсах, когда вы начинаете
новый проект, вы должны это сделать.

 [1]: http://flippinawesome.org/authors/tim-severien
 [2]: http://css-tricks.com/video-screencasts/124-a-modern-web-designers-workflow/
 [3]: http://www.sitepoint.com/architecture-sass-project/
